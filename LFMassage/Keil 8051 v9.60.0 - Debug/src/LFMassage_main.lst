C51 COMPILER V9.60.0.0   LFMASSAGE_MAIN                                                    10/13/2021 21:46:01 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE LFMASSAGE_MAIN
OBJECT MODULE PLACED IN .\src\LFMassage_main.OBJ
COMPILER INVOKED BY: C:\SiliconLabs\SimplicityStudio\v5\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\Users\donny\S
                    -implicityStudio\v5_workspace\LFMassage\src\LFMassage_main.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLO
                    -ATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\donny\SimplicityStudio\v5_work
                    -space\LFMassage\inc;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.1//Device/shared/si8051Base;C:/SiliconLa
                    -bs/SimplicityStudio/v5/developer/sdks/8051/v4.2.1//Device/EFM8BB1/inc) PRINT(.\src\LFMassage_main.lst) COND PAGEWIDTH(12
                    -0) PAGELENGTH(65) OBJECT(.\src\LFMassage_main.OBJ)

line level    source

   1          //=========================================================
   2          // src/LFMassage_main.c: generated by Hardware Configurator
   3          //
   4          // This file will be updated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!!
   7          //=========================================================
   8          
   9          //-----------------------------------------------------------------------------
  10          // Includes
  11          //-----------------------------------------------------------------------------
  12          #include <SI_EFM8BB1_Register_Enums.h>                  // SFR declarations
  13          #include "InitDevice.h"
  14          #include "driver.h"
  15          // $[Generated Includes]
  16          // [Generated Includes]$
  17          
  18          #define TIM0CLK       2083333          // Clock speed in Hz
  19          
  20          void initialize(void);
  21          void enter_lowpower(void);
  22          void beep(void);
  23          void Timer0_Delay (uint16_t us);
  24          
  25          typedef enum {
  26            MODE_READY = 0,
  27            MODE_RED,
  28            MODE_GRN,
  29            MODE_BLU,
  30            MODE_MAX
  31          } mode_t;
  32          typedef enum {
  33            MAG_0 = 0,
  34            MAG_1,
  35            MAG_2,
  36            MAG_3,
  37            MAG_4,
  38            MAG_5,
  39            MAG_MAX
  40          } magnitude_t;
  41          
  42          mode_t mode = MODE_BLU;
  43          magnitude_t mag = MAG_0;
  44          static uint32_t chrg_ref_mV = 100;
  45          
  46          //-----------------------------------------------------------------------------
  47          // SiLabs_Startup() Routine
  48          // ----------------------------------------------------------------------------
  49          // This function is called immediately after reset, before the initialization
  50          // code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
  51          // useful place to disable the watchdog timer, which is enable by default
C51 COMPILER V9.60.0.0   LFMASSAGE_MAIN                                                    10/13/2021 21:46:01 PAGE 2   

  52          // and may trigger before main() in some instances.
  53          //-----------------------------------------------------------------------------
  54          void SiLabs_Startup (void)
  55          {
  56   1        // $[SiLabs Startup]
  57   1        // [SiLabs Startup]$
  58   1      }
  59          
  60          //-----------------------------------------------------------------------------
  61          // main() Routine
  62          // ----------------------------------------------------------------------------
  63          int main (void)
  64          {
  65   1        WDT_0_enter_DefaultMode_from_RESET();
  66   1      
  67   1      //  Timer0_Delay(500);
  68   1        //P0MDIN |= P0MDIN_B1__DIGITAL;
  69   1        if (P0_B1 != 0) {
  70   2            enter_lowpower();
  71   2        }
  72   1        //P0MDIN &= ~P0MDIN_B1__DIGITAL;
  73   1        WDTCN = 0xA5;
  74   1      
  75   1        // Call hardware initialization routine
  76   1        enter_DefaultMode_from_RESET();
  77   1      
  78   1        initialize();
  79   1        IE_EA = 1;
  80   1      
  81   1        while (1) 
  82   1        {
  83   2            WDTCN = 0xA5;
  84   2          // $[Generated Run-time code]
  85   2          // [Generated Run-time code]$
  86   2            switch (mode) {
  87   3              case MODE_READY:
  88   3                break;
  89   3              case MODE_RED:
  90   3                TMR2CN0_TR2 = 1;
  91   3                pulseNeg(100);
  92   3                Timer0_Delay(100);
  93   3                pulseNeg(100);
  94   3                Timer0_Delay(100);
  95   3                TMR2CN0_TR2 = 0;
  96   3                Timer0_Delay(2000);
  97   3                break;
  98   3              case MODE_GRN:
  99   3                break;
 100   3              case MODE_BLU:
 101   3                break;
 102   3            }
 103   2      
 104   2            if (getBtnMode()) {
 105   3                setBtnMode(false);
 106   3                beep();
 107   3      
 108   3                mode++;
 109   3                if (mode == MODE_MAX) mode = MODE_READY;
 110   3      
 111   3                switch (mode) {
 112   4                  case MODE_READY:
 113   4                    setLedRed(false);
 114   4                    setLedGrn(false);
C51 COMPILER V9.60.0.0   LFMASSAGE_MAIN                                                    10/13/2021 21:46:01 PAGE 3   

 115   4                    setLedBlu(false);
 116   4                    setIrLed(false);
 117   4                    beep();
 118   4                    break;
 119   4                  case MODE_RED:
 120   4                    setLedRed(true);
 121   4                    setLedGrn(false);
 122   4                    setLedBlu(false);
 123   4                    setIrLed(true);
 124   4                    Timer0_Delay(100);
 125   4                    break;
 126   4                  case MODE_GRN:
 127   4                    setLedRed(false);
 128   4                    setLedGrn(true);
 129   4                    setLedBlu(false);
 130   4                    setIrLed(true);
 131   4                    Timer0_Delay(100);
 132   4                    break;
 133   4                  case MODE_BLU:
 134   4                    setLedRed(false);
 135   4                    setLedGrn(false);
 136   4                    setLedBlu(true);
 137   4                    setIrLed(true);
 138   4                    Timer0_Delay(100);
 139   4                    break;
 140   4                }
 141   3                beep();
 142   3            } else if (getBtnPlus()) {
 143   3                setBtnPlus(false);
 144   3                mag++;
 145   3                if (mag == MAG_MAX) mag--;
 146   3                switch (mag) {
 147   4                  case MAG_0: chrg_ref_mV = 100; break;
 148   4                  case MAG_1: chrg_ref_mV = 300; break;
 149   4                  case MAG_2: chrg_ref_mV = 500; break;
 150   4                  case MAG_3: chrg_ref_mV = 700; break;
 151   4                  case MAG_4: chrg_ref_mV = 900; break;
 152   4                  case MAG_5: chrg_ref_mV = 1100; break;
 153   4                }
 154   3      
 155   3                beep();
 156   3            } else if (getBtnMinus()) {
 157   3                setBtnMinus(false);
 158   3                if (mag != MAG_0) mag--;
 159   3                switch (mag) {
 160   4                  case MAG_0: chrg_ref_mV = 100; break;
 161   4                  case MAG_1: chrg_ref_mV = 300; break;
 162   4                  case MAG_2: chrg_ref_mV = 500; break;
 163   4                  case MAG_3: chrg_ref_mV = 700; break;
 164   4                  case MAG_4: chrg_ref_mV = 900; break;
 165   4                  case MAG_5: chrg_ref_mV = 1100; break;
 166   4                }
 167   3      
 168   3                beep();
 169   3            }
 170   2        }                             
 171   1      }
 172          
 173          void initialize(void)
 174          {
 175   1        offSwitch();
 176   1      
 177   1        setLedRed(false);
C51 COMPILER V9.60.0.0   LFMASSAGE_MAIN                                                    10/13/2021 21:46:01 PAGE 4   

 178   1        setLedGrn(false);
 179   1        setLedBlu(false);
 180   1        setIrLed(false);
 181   1      }
 182          
 183          void enter_lowpower(void)
 184          {
 185   1        P0MDIN = 0;
 186   1        P0MDOUT = 0;
 187   1        P1MDIN = 0;
 188   1        P1MDOUT = 0;
 189   1      //  RSTSRC |= RSTSRC_C0RSEF__SET;
 190   1        RSTSRC |= RSTSRC_WDTRSF__SET;
 191   1      
 192   1        // REG0CN |= REG0CN_STOPCF__SHUTDOWN;
 193   1      
 194   1        PCON0 |= PCON0_STOP__BMASK;
 195   1      //  PCON0 = PCON0_IDLE__IDLE;
 196   1      }
 197          
 198          void beep(void)
 199          {
 200   1        TMR3CN0 |= TMR3CN0_TR3__RUN;
 201   1        Timer0_Delay(200);
 202   1        TMR3CN0 &= ~TMR3CN0_TR3__RUN;
 203   1        offBuzz();
 204   1      }
 205          
 206          void Timer0_Delay (uint16_t ms)
 207          {
 208   1         unsigned i;                         // Millisecond counter
 209   1      
 210   1         for (i = 0; i < ms; i++)            // Count microseconds
 211   1         {
 212   2            TCON &= ~0x30;                   // STOP Timer0 and clear overflow
 213   2            TH0 = (-TIM0CLK/1000) >> 8;    // Set Timer0 to overflow in 1us
 214   2            TL0 = -TIM0CLK/1000;
 215   2            TCON |= 0x10;                    // START Timer0
 216   2            while (TCON_TF0 == 0) {
 217   3                WDTCN = 0xA5;           // Wait for overflow
 218   3            }
 219   2         }
 220   1      }
 221          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    472    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
